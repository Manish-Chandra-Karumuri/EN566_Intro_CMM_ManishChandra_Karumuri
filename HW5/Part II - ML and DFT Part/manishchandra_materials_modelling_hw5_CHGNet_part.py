# -*- coding: utf-8 -*-
"""ManisChandra.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15jCJCY3KXR89gog7UnssCNRpnkfr7_HM

# MLFF (Machine Learning Force Field) Tutorial with CHGNet

This tutorial demonstrates how to use CHGNet for structure relaxation and energy/force prediction compared with DFT results.

## What is CHGNet?

CHGNet (Crystal Hamiltonian Graph neural Network) is a pretrained universal neural network potential that can predict:
- **Energy** (eV/atom)
- **Forces** (eV/Å)
- **Stress** (GPa)
- **Magnetic moments** (μB)

It was trained on over 1.5 million structures from the Materials Project database and provides near-DFT accuracy for atomistic simulations.
"""

# Commented out IPython magic to ensure Python compatibility.
#check the current path
import os
print(os.getcwd())

#Lists the files in the current directory
!ls
!git clone https://github.com/hguangshuai/intro_ML_for_MSE
# %cd intro_ML_for_MSE

# Install required packages
# %pip install chgnet
# %pip install pymatgen
# %pip install matplotlib
# %pip install numpy

print("✓ All packages installed successfully!")
#MatBench Leaderboard
#https://matbench-discovery.materialsproject.org/

# Import libraries
import os
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import warnings
warnings.filterwarnings("ignore")

# Import pymatgen for structure handling
from pymatgen.core import Structure
from pymatgen.io.vasp import Poscar

# Import CHGNet components
from chgnet.model.model import CHGNet
from chgnet.model import StructOptimizer

print("✓ All libraries imported successfully!")

# Load CHGNet model
print("Loading CHGNet model...")
chgnet = CHGNet.load()
print("✓ CHGNet model loaded successfully!")

# Load one POSCAR file using pymatgen Structure.from_str() method
file_path = '/content/intro_ML_for_MSE/Data/poscar/LiOSi_-7.0131.poscar'

print(f"Loading {file_path}...")
filename = os.path.basename(file_path)
dft_energy = float(filename.split('_')[1].replace('.poscar', ''))




# Read POSCAR file content as string
with open(file_path, 'r') as f:
    poscar_str = f.read()

# Use pymatgen to read POSCAR from string
structure = Structure.from_str(poscar_str, fmt="poscar")

print(f"✓ Successfully loaded {file_path}")
print(f"Composition: {structure.composition}")
print(f"Formula: {structure.formula}")
print(f"Atoms: {len(structure)}")
print(f"DFT Energy: {dft_energy:.6f} eV/atom")
print(structure)

from chgnet.model import StructOptimizer

relaxer = StructOptimizer()
result = relaxer.relax(structure)
print("CHGNet relaxed structure", result["final_structure"])
print("relaxed total energy in eV:", result['trajectory'].energies[-1])

#get No. of atoms
print("No. of atoms:", len(structure))

#calculate energy per atom
print("Energy per atom:", result['trajectory'].energies[-1] / len(structure))

#calculate force magnitude
print("Force magnitude:", np.linalg.norm(result['trajectory'].forces[-1]))

# After relaxation
chgnet_energy_per_atom = result['trajectory'].energies[-1] / len(structure)
print(f"\nEnergy Comparison:")
print(f"DFT Energy: {dft_energy:.6f} eV/atom")
print(f"CHGNet Energy: {chgnet_energy_per_atom:.6f} eV/atom")
print(f"Difference: {abs(dft_energy - chgnet_energy_per_atom):.6f} eV/atom")

# Calculate force statistics
forces = result['trajectory'].forces[-1]
force_magnitudes = np.linalg.norm(forces, axis=1)
print(f"\nForce Statistics:")
print(f"Max force: {np.max(force_magnitudes):.6f} eV/Å")
print(f"Mean force: {np.mean(force_magnitudes):.6f} eV/Å")
print(f"Min force: {np.min(force_magnitudes):.6f} eV/Å")

# 5. Optional: Add visualization
# Plot energy vs relaxation step
plt.figure(figsize=(10, 6))
energies_per_atom = [e / len(structure) for e in result['trajectory'].energies]
plt.plot(energies_per_atom, 'b-', linewidth=2, marker='o', markersize=6)
plt.axhline(y=dft_energy, color='r', linestyle='--', label=f'DFT Energy: {dft_energy:.4f} eV/atom')
plt.xlabel('Relaxation Step')
plt.ylabel('Energy (eV/atom)')
plt.title('Energy during CHGNet Relaxation')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# Compare initial and final structures
from pymatgen.analysis.structure_matcher import StructureMatcher

matcher = StructureMatcher()
is_same = matcher.fit(structure, result["final_structure"])
rms_dist = matcher.get_rms_dist(structure, result["final_structure"])

print(f"\nStructural Changes:")
print(f"Structures are similar: {is_same}")
if rms_dist:
    print(f"RMS displacement: {rms_dist[0]:.6f} Å")

# Volume change
initial_volume = structure.volume
final_volume = result["final_structure"].volume
volume_change = (final_volume - initial_volume) / initial_volume * 100

print(f"Initial volume: {initial_volume:.3f} Cu. Å")
print(f"Final volume: {final_volume:.3f} Cu. Å")
print(f"Volume change: {volume_change:.2f}%")

"""#Optimizing all POSCAR files in the directory

"""

# Process multiple POSCAR files to see trends
import glob
import pandas as pd

# Get all POSCAR files
poscar_files = glob.glob('/content/intro_ML_for_MSE/Data/poscar/*.poscar')
print(f"Found {len(poscar_files)} POSCAR files")

# Process first 10 files (or adjust as needed)
results_summary = []
n_files = min(10, len(poscar_files))  # Process up to 10 files

for i, file_path in enumerate(poscar_files[:n_files]):
    print(f"\nProcessing file {i+1}/{n_files}: {os.path.basename(file_path)}")

    try:
        filename = os.path.basename(file_path)
        dft_energy = float(filename.split('_')[1].replace('.poscar', ''))

        with open(file_path, 'r') as f:
            structure = Structure.from_str(f.read(), fmt="poscar")

        # Relax with CHGNet
        result = relaxer.relax(structure, verbose=False)
        chgnet_energy = result['trajectory'].energies[-1] / len(structure)

        # Calculate forces
        final_forces = result['trajectory'].forces[-1]
        max_force = np.max(np.linalg.norm(final_forces, axis=1))

        results_summary.append({
            'formula': structure.formula,
            'n_atoms': len(structure),
            'dft_energy': dft_energy,
            'chgnet_energy': chgnet_energy,
            'difference': chgnet_energy - dft_energy,
            'max_force': max_force,
            'n_steps': len(result['trajectory'].energies)
        })

    except Exception as e:
        print(f"Error processing {filename}: {e}")
        continue

# Convert to DataFrame for easier analysis
df_results = pd.DataFrame(results_summary)
print("\n" + "="*80)
print("SUMMARY OF RESULTS")
print("="*80)
print(df_results.to_string(index=False))

# Create visualization of DFT vs CHGNet energies
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# 1. Parity plot
ax1 = axes[0, 0]
ax1.scatter(df_results['dft_energy'], df_results['chgnet_energy'], alpha=0.7, s=100)
min_e = min(df_results['dft_energy'].min(), df_results['chgnet_energy'].min())
max_e = max(df_results['dft_energy'].max(), df_results['chgnet_energy'].max())
ax1.plot([min_e, max_e], [min_e, max_e], 'r--', label='Perfect agreement')
ax1.set_xlabel('DFT Energy (eV/atom)')
ax1.set_ylabel('CHGNet Energy (eV/atom)')
ax1.set_title('DFT vs CHGNet Energy Comparison')
ax1.legend()
ax1.grid(True, alpha=0.3)

# 2. Energy difference histogram
ax2 = axes[0, 1]
ax2.hist(df_results['difference'], bins=20, alpha=0.7, color='blue', edgecolor='black')
ax2.set_xlabel('Energy Difference (CHGNet - DFT) (eV/atom)')
ax2.set_ylabel('Count')
ax2.set_title('Distribution of Energy Differences')
ax2.axvline(x=0, color='red', linestyle='--', label='Zero difference')
ax2.grid(True, alpha=0.3)

# 3. Energy difference vs composition size
ax3 = axes[1, 0]
ax3.scatter(df_results['n_atoms'], df_results['difference'], alpha=0.7, s=100)
ax3.set_xlabel('Number of Atoms')
ax3.set_ylabel('Energy Difference (eV/atom)')
ax3.set_title('Energy Difference vs System Size')
ax3.axhline(y=0, color='red', linestyle='--')
ax3.grid(True, alpha=0.3)

# 4. Convergence steps
ax4 = axes[1, 1]
ax4.bar(range(len(df_results)), df_results['n_steps'], alpha=0.7)
ax4.set_xlabel('Structure Index')
ax4.set_ylabel('Relaxation Steps')
ax4.set_title('Number of Relaxation Steps per Structure')
ax4.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

# Print statistics
print("\nSTATISTICS:")
print(f"Mean energy difference: {df_results['difference'].mean():.4f} ± {df_results['difference'].std():.4f} eV/atom")
print(f"Mean absolute error: {df_results['difference'].abs().mean():.4f} eV/atom")
print(f"Max absolute error: {df_results['difference'].abs().max():.4f} eV/atom")
print(f"Percentage with CHGNet < DFT: {(df_results['difference'] < 0).sum() / len(df_results) * 100:.1f}%")

# Group by chemical composition patterns
# Extract elements from formulas
df_results['elements'] = df_results['formula'].apply(lambda x: ''.join([c for c in x if c.isalpha()]))

# Group by element combinations
element_groups = df_results.groupby('elements').agg({
    'difference': ['mean', 'std', 'count'],
    'formula': 'first'
}).round(4)

print("\nENERGY DIFFERENCES BY ELEMENT COMBINATION:")
print(element_groups)

# Check if certain elements lead to larger differences
all_elements = set()
for formula in df_results['formula']:
    all_elements.update([c for c in formula if c.isalpha()])

element_differences = {}
for element in all_elements:
    mask = df_results['formula'].str.contains(element)
    if mask.sum() > 0:
        element_differences[element] = df_results.loc[mask, 'difference'].mean()

# Sort by difference
sorted_elements = sorted(element_differences.items(), key=lambda x: x[1])
print("\nAVERAGE ENERGY DIFFERENCE BY ELEMENT PRESENCE:")
for element, diff in sorted_elements:
    count = df_results['formula'].str.contains(element).sum()
    print(f"{element}: {diff:+.4f} eV/atom (in {count} structures)")

# Test energy and force predictions without relaxation
test_structure = structure  # Use the last loaded structure

# Get predictions without relaxation
prediction = chgnet.predict_structure(
    test_structure,
    return_site_energies=True,
    return_atom_feas=False,
    return_crystal_feas=False
)

print("\nCHGNet PREDICTIONS (without relaxation):")
print(f"Total energy: {prediction['e']:.4f} eV")
print(f"Energy per atom: {prediction['e']/len(test_structure):.4f} eV/atom")
print(f"Forces shape: {prediction['f'].shape}")
print(f"Max force component: {np.abs(prediction['f']).max():.4f} eV/Å")
print(f"Stress tensor (GPa):")
print(prediction['s'])
if 'm' in prediction:
    print(f"Magnetic moments: {prediction['m']}")

# Visualize site energies if available
if 'site_energies' in prediction:
    plt.figure(figsize=(8, 6))
    site_energies = prediction['site_energies']
    plt.hist(site_energies, bins=20, alpha=0.7, edgecolor='black')
    plt.xlabel('Site Energy (eV)')
    plt.ylabel('Count')
    plt.title('Distribution of Atomic Site Energies')
    plt.grid(True, alpha=0.3)
    plt.show()

# Calculate a simple linear correction
from sklearn.linear_model import LinearRegression

# Fit linear model
X = df_results['dft_energy'].values.reshape(-1, 1)
y = df_results['chgnet_energy'].values
model = LinearRegression()
model.fit(X, y)

print(f"\nLinear Correction Model:")
print(f"Slope: {model.coef_[0]:.4f}")
print(f"Intercept: {model.intercept_:.4f}")

# Apply correction
df_results['chgnet_corrected'] = model.predict(X)
df_results['corrected_difference'] = df_results['chgnet_corrected'] - df_results['dft_energy']

# Plot corrected results
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.scatter(df_results['dft_energy'], df_results['chgnet_energy'], alpha=0.7, label='Original CHGNet')
plt.scatter(df_results['dft_energy'], df_results['chgnet_corrected'], alpha=0.7, label='Corrected CHGNet')
plt.plot([df_results['dft_energy'].min(), df_results['dft_energy'].max()],
         [df_results['dft_energy'].min(), df_results['dft_energy'].max()], 'r--', label='Perfect agreement')
plt.xlabel('DFT Energy (eV/atom)')
plt.ylabel('Energy (eV/atom)')
plt.title('Energy Correction Effect')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.hist(df_results['corrected_difference'], bins=20, alpha=0.7, edgecolor='black')
plt.xlabel('Corrected Energy Difference (eV/atom)')
plt.ylabel('Count')
plt.title('Distribution after Linear Correction')
plt.axvline(x=0, color='red', linestyle='--')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"\nAfter correction:")
print(f"Mean absolute error: {df_results['corrected_difference'].abs().mean():.4f} eV/atom")
print(f"Max absolute error: {df_results['corrected_difference'].abs().max():.4f} eV/atom")

# Example: Calculate formation energy
# Using LiOSi as example
li_osi_structure = structure  # Your loaded structure

# Reference energies (you would need actual values)
# These are example values - replace with real reference energies
ref_energies = {
    'Li': -1.90,  # eV/atom
    'O': -4.95,   # eV/atom
    'Si': -5.43   # eV/atom
}

# Calculate formation energy
composition = li_osi_structure.composition
total_atoms = sum(composition.values())

# DFT formation energy
dft_total = dft_energy * total_atoms
ref_total = sum(composition[el] * ref_energies.get(str(el), 0) for el in composition)
dft_formation = (dft_total - ref_total) / total_atoms

# CHGNet formation energy
chgnet_total = chgnet_energy_per_atom * total_atoms
chgnet_formation = (chgnet_total - ref_total) / total_atoms

print("\nFORMATION ENERGY CALCULATION:")
print(f"Composition: {composition}")
print(f"DFT formation energy: {dft_formation:.4f} eV/atom")
print(f"CHGNet formation energy: {chgnet_formation:.4f} eV/atom")
print(f"Difference: {chgnet_formation - dft_formation:.4f} eV/atom")

import time

# Benchmark CHGNet vs DFT computational cost
print("\nCOMPUTATIONAL PERFORMANCE:")

# Time CHGNet prediction
start = time.time()
for _ in range(10):
    prediction = chgnet.predict_structure(test_structure)
chgnet_time = (time.time() - start) / 10

# Time CHGNet relaxation
start = time.time()
result = relaxer.relax(test_structure, steps=50)
relax_time = time.time() - start

print(f"CHGNet single-point prediction: {chgnet_time*1000:.2f} ms")
print(f"CHGNet relaxation (50 steps): {relax_time:.2f} s")
print(f"Typical DFT single-point: ~60-300 s (100-1000x slower)")
print(f"Typical DFT relaxation: ~1-10 hours (1000-10000x slower)")

# Calculate speedup
speedup_prediction = 180 / chgnet_time  # Assuming 3 min for DFT
speedup_relaxation = 3600 / relax_time  # Assuming 1 hour for DFT

print(f"\nEstimated speedup:")
print(f"Single-point: {speedup_prediction:.0f}x")
print(f"Relaxation: {speedup_relaxation:.0f}x")